Go Performance Tutorial

Josh Bleecher Snyder
Braintree/PayPal
josharian@gmail.com
@offbymany

# introduce myself, contributions to Go, etc.


* Plan

- Introduction and philosophy
- Tools: Benchmarks, profiles

- Break

- Techniques: string/[]byte, memory, concurrency
- Advanced tools and techniques
- Other kinds of optimization
- Wrap-up and stump the chump


* Introduction and philosophy

# lots to say, so there will be interludes throughout
# but here are the key points


* Write simple, clear code

- Usually the fastest anyway

.link https://codereview.appspot.com/131840043

- Easy to see optimization opportunities
- Compiler and runtime optimized for normal code
- Take it easy on abstraction (reflection, interfaces)

"All problems in computer science can be solved by another level of indirection, except of course for the problem of too many indirections." - David Wheeler

* Write good tests and use version control

Enables experimentation.

"If you're not going to get the right answer, I don't see the point. I can make things very fast if they don't have to be correct." - Russ Cox


* Develop good habits

"Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%." - Donald Knuth

# we'll discuss good habits as we go
# get the basics right: caching, lazy initialization, better algorithms


* Know thy tools, at all levels

- Can you cheat? Does it matter?
- Algorithms
- Language
- Benchmarking and profiling
- Machine and OS: Disk vs network vs memory

"People who are more than casually interested in computers should have at least some idea of what the underlying hardware is like. Otherwise the programs they write will be pretty weird." - Donald Knuth


* The easiest wins around

- Use the most recent release of Go!
- Use more hardware.


* Benchmarking


* Hello, benchmarks

Demo: package fib

# how to write, run, and interpret a benchmark
# adaptive benchtime
# -bench=regexp, -run=NONE, -benchtime
# full power of language at disposal
# careful about which benchmarks you write
# beware microbenchmarks

* Tour of testing.B and 'go test' flags

Demo: word length count

# b.SetBytes
# -benchmem, b.ReportAllocs
# b.Errorf, b.Logf, -v
# danger: these skew benchmarking! demo with ReportAllocs
# and wow, reflect.DeepEqual is expensive!
# b.ResetTimer, b.StopTimer, b.StartTimer
# show Go 1.4 vs Go tip (1.5)


* Comparing benchmarks

- benchcmp

	go get -u golang.org/x/tools/cmd/benchcmp

- benchviz

	go get -u github.com/ajstarks/svgo/benchviz

- benchstat

	go get -u rsc.io/benchstat

# hope for more in 1.6


* Benchmarking concurrent code

Demo: ngram

# -cpu, b.PB, b.RunParallel, b.SetParallelism
# how to set up global state and goroutine-local state
# what it does under the hood
# tip: Use rand.Zipf to simulate real load


* Profiling

* Hello, profiling

- Where have all the cycles gone?
- Support built into the runtime
- `go`tool`pprof`, graphviz
- OS X sadness


# helps you understand you program's performance via instrumentation
# different kinds of profiling: cpu, memory, block profiling, tracing
# cpu works by sampling, with support from the OS; OS X needs a patch
# other kinds of profiling work using instrumentation in the runtime
# cpu is efficient, can run on live production server, memory less so
# different kinds of profiling interfere with each other

# NetBSD also has (had?) broken profiling


* CPU profiling

Demo: fib

# show basic usage: -cpuprofile, -outputdir
# saves binary
# don't run any tests, target individual benchmarks
# -lines -pdf -nodecount=10 -focus=fib 
# be careful about hiding things!
# mention:
#  can set CPU profiling rate


* Memory profiling

Demo: ascii

# start with load
# discover syscalls
# remove syscalls

# discover malloc
# add ReportAllocs
# do mem profiling
# need -l
# need -alloc_objects, discuss alternatives
# discuss -memprofilerate

# move on to encode
# discover malloc
# add ReportAllocs
# mem profiling
# need -l? nope.
# need -runtime flag to pprof
# aha! string concatenation. Use a bytes.Buffer. Will discuss more later. common problem.

# syscall: look at syscalls. malloc: look at allocation. mutex/futex/channel-y things? look at blocking. We'll get to that.


* Profiling gotchas

- Don't run multiple profilers at once.
- Don't run tests when profiling.
- If the output doesn't make sense, poke around or ask for help.

# pprof has a crappy UI. Live with it. :(


* Block profiling

Demo: ngram

# easy demo: -blockprofile=
# discuss -blockprofilerate, -memprofilerate
# there is a way to change cpu profile rate in runtime package but too fast can't happen (OS support, expense of walking the stack) and the default is pretty good
# discuss ok/expected blocking: time.Ticker, sync.WaitGroup


* Other kinds of profiling

In package `runtime/pprof`:

- `goroutine`: helpful for finding sources of leaking goroutines
- `threadcreate` helpful for debugging runaway thread creation (usually syscalls or cgo)

# TODO: Expand?

Basic memory stats available in package `runtime`: `ReadMemStats`

.link https://golang.org/pkg/runtime/#MemStats


* Whole program profiling

Set up first thing in `func`main`.

Use `runtime` and `runtime/pprof`...but it is a pain.

# Mention gotchas like flushing and closing the files,
# calling runtime.GC before exit, etc.

Dave Cheney made a nice helper package:

	go get -u github.com/pkg/profile

.link https://godoc.org/github.com/pkg/profile


* Monitoring live servers

Cheap enough to do in production!

And easy, using `net/http/pprof`.

	import _ "net/http/pprof"

Use pprof to view CPU:

	go tool pprof -pdf http://localhost:4001/debug/pprof/profile > o.pdf && open o.pdf

Heap:

	go tool pprof http://localhost:4001/debug/pprof/heap

Goroutines:

	go tool pprof http://localhost:4001/debug/pprof/goroutine

See `net/http/pprof` docs.


* Monitoring live servers

Demo: present

	go tool pprof -pdf http://localhost:4001/debug/pprof/goroutine > o.pdf && open o.pdf

Oh goodness!

.link https://github.com/golang/go/issues/11507


* Protecting the net/http/pprof endpoints

`net/http/pprof` registers endpoints with `http.DefaultServeMux`.

So don't use `http.DefaultServeMux`.

	serveMux := http.NewServeMux()
	// use serveMux to serve your regular website

	pprofMux := http.NewServeMux()
	pprofMux.HandleFunc("/debug/pprof/", pprof.Index)
	pprofMux.HandleFunc("/debug/pprof/cmdline", pprof.Cmdline)
	pprofMux.HandleFunc("/debug/pprof/profile", pprof.Profile)
	pprofMux.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
	// use pprofMux to serve the pprof handles

Or use a single non-default `ServeMux` but insert http handler middleware.


* Execution tracing

- New as of Go 1.5! Google for "Go execution tracer" to see the design doc.
- A few rough edges still.
- Incredibly detailed and powerful, with all the good and bad that that brings.


* Execution tracing

Demo: ngram

# go test -bench=. -trace=trace.out -benchtime=50ms
# go tool trace ngram.test trace.out

# before and after
# observe blocked goroutines before, interleaved goroutines after

# play with it and explore. I still am.


* Break

# switch to present14!


* Techniques and habits


* string and []byte

Common source of performance problems.
Easy to learn good habits.
Helps to know what's happening under the hood.


* string and []byte

*string*

- basic type
- interpreted as UTF-8
- _immutable_

*[]byte*

- just another slice type
- no particular interpretation
- _mutable_

.play stringbytes/mutable.go /func set/,/^}/


* string and []byte

Above all, the compiler and runtime must be correct.
Speed is a bonus.

In the general case, converting between string and []byte requires an alloc and a copy.

.play stringbytes/convert.go /func Benchmark/,/^}/


* string and []byte

*string*

- slicing is very cheap and safe
- concatenation is expensive (alloc + copy x 2)

*[]byte*

- slicing is very cheap but not always safe
- append is sometimes expensive (sometimes alloc, always copy x 1, sometimes copy x 2)


* string and []byte

Good habits:

- Live in just one world (modulo code clarity and correctness).
- Convert as late as possible.
- Pay attention to concatenation, particularly in loops.

# that's why we have parallel strings and bytes packages
# now specific techniques/habits
# these are not rules. clarity trumps, but these are generally equally clear.
# these might only matter in loops. but get in the habit of writing performant code.


* string and []byte

Use a bytes.Buffer to build strings.

.play stringbytes/buf.go /func Benchmark/,/^$/

# important change for c2go compiler performance!


* string and []byte

Use dedicated APIs:

- "io.Writer".Write vs io.WriteString
- "bufio.Scanner".Bytes vs "bufio.Scanner".Text
- "bytes.Buffer".Bytes vs "bytes.Buffer".String

And implement WriteString for your io.Writers:

	func WriteString(s string) (n int, err error)


* string and []byte

If the set of choices is small, pick a string rather than building it.
(Or use stringer: golang.org/x/tools/cmd/stringer.)

# TODO: Example code with benchmark


* string and []byte

Slice after converting.

.play stringbytes/slice.go /Repeat/,/func _/


* string and []byte

Use concatenation and strconv instead of fmt.Sprintf for simple things.

.play stringbytes/strconv.go /func Benchmark/,/^$/


* string and []byte

Design your APIs to allow reduced garbage.

- Provide []byte and string variants.
- Use io.Reader and io.Writer instead of buffers.
- BYO buffer.


* string and []byte

Techniques:

- Reuse buffers.
- Take advantage of compiler optimizations.
- Intern strings.

# distinguish habits from techniques:
# habits are things you should usually do;
# techniques are things to use when profiling says you need to optimize.

# compiler optimization overlaps with "delay conversion"


* string and []byte

.play stringbytes/reuse.go /pool/,/func _/

# can also reuse with a local free list. do whatever is appropriate.
# note that sync.Pool's efficiency is implementation-dependent.


* string and []byte

Pop quiz: How many allocs/op in this benchmark?

.play stringbytes/convertnoescape.go /Benchmark/,/^}/

# answer: it varies!
# Go 1.4: 1
# Go 1.5: 0
# Go 1.5, with a longer byte slice: 1!
# explain escape analysis, compiler optimizations


* string and []byte

Conversion optimizations in Go 1.5 include:

- map keys
- range expressions
- concatenation
- comparisons

Convert as late as possible to enable them to work.
(Future work may change that.)

More are possible. Those that work well on normal code will eventually be implemented.


* string and []byte

The map key optimization is particularly interesting.

.play stringbytes/mapkey.go /Repeat/,/func _/


* string and []byte

.play stringbytes/intern.go /interned/,/func _/


* string and []byte

Be careful with interning!

- Advanced technique. Use with caution, only when necessary.
- Depends on compiler version.
- *Manual*memory*management!* Ewwwwww.
- Not thread safe. (But see github.com/josharian/intern for a hack.)


* Optimizing memory usage


* Optimizing memory usage

TODO
