SLIDE WIP

# TODO: Expand? Demo?




07. Advanced optimization techniques
	0701 Compiler flags
		Main goal is to learn and experiment.
		How to use, how to interpret results.
		Flags: -h -m -S -l -N -g -B
	0702 Runtime hooks
		GODEBUG=gctrace=1
		GODEBUG=allocfreetrace=1
		GODEBUG=schedtrace=1000
		GOGC
		Gosched
	0703 Assembly, cgo
		When and why (not) to use.
		Overhead and granularity.
		Show examples.
		Use vet to catch obvious mistakes.
	0704 Code generation
		Use to avoid interfaces, callbacks, or reflection.
		Use to generate hard to read code that is still correct. (e.g. stringer)
		Use to unroll loops or calculations or to generate pre-calculated tables.
	0705 Micro-optimizations
		Caution! Make sure this is really important.
		Special idioms: optimized memclear, rotate instruction.
		Use arrays instead of maps for lookups with small int keys.
		Use a slice instead of a map for very small data structures.
		Defer can be expensive -- manually unwind.

08. Other kinds of optimization
	0801 Optimizing binary size
		Drop DWARF, symbol tables.
		Take care with large static data,
		particularly large static arrays.
		go tool nm and friends.
		Millions of tiny strings: slice a big string.
	0802 Optimizing build time
		go install vs go build
		Split up crazy long functions
		Separate giant tables from code with lots of churn
		File issues!

09. Conclusion
	0901 Resourses and Where to Go From Here
		golang-nuts, Dmitry's work, stdlib
		Profile your own code. Know when to stop.
		Pick an open source project and
		find and fix a major performance problem.
	0902 Wrap Up
		What we covered. Your newfound abilities.
		Reminder of basic principles: Write simple,
		clear code, write tests, develop good habits,
		go deep when it matters.






* HABITS TO COVER:

# Buffer i/o. Pass giant values using pointers.
# Read the docs, pay attention to loops, use the most recent version of Go.
# stream instead of buffering


* Good habits, part 1

- Write clear code
# makes it easier to see optimization opportunities
# clear code is usually simple, and simple is usually fast

- Write good tests
# facilitates rapid experimentation

- Read the docs
# they usually provide perf info when important
# they tell you whether you can reuse/share things
# particularly the testing package -- there's lots there

- Pay attention to loops


* Good habits, part 2

- Know what allocates
# you don't have to avoid allocations necessarily; just be aware

- Pay attention to data growth: append, concat, map assign

- Provide initial capacity estimates when reasonable

- Pay attention to string/[]byte conversions
# they are an alloc+copy


* Good habits, part 3

- Stream when possible
# json.NewEncoder instead of json.Marshal)

- Buffer I/O
# each syscall has a cost

- Careful API design
# allow streaming, allow Bring Your Own Buffer

- Avoid gratuitous boxing, reflection, and indirection
# they come with significant cost to perf and readability
# you frequently don't need them

- Use mutexes instead of channels for simple shared state


* I'm stuck

- Experiment, then analyze

# RWMutex sometimes slower than Mutex
# small maps sometimes slower than slices

- Email golang-nuts (but do your homework first)

# but do your homework first

- Beware microbenchmarks

# always keep the context in mind
# gather data to help you decide; Go is machine-friendly, so this is easy

- Read "Debugging performance issues in Go programs" by Dmitry Vyukov


* Stump the chump


* Concurrent performance

- testing.PB and RunParallel

- Block profiling

- Free lists and sync.Pool

# local vs shared; when to use

- Partition shared data structures

- Use buffered channels


* Advanced techniques

- Know thy gcflags: -S, -B, -m

# discover with 'go tool 6g -h'

- Defer can be expensive

- Amortize expensive work

- Combine allocations

- Scheduler trace, gc trace

- Codegen for specialization
